<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tracklistify Studio</title>
    
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.3/dist/cdn.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="/static/css/style.css">

    <script>
        document.addEventListener('alpine:init', () => {
            Alpine.data('tracklistify', () => ({
                // --- 1. NAVIGATION & UI STATE ---
                currentView: 'dashboard', 
                search: '',
                
                ui: {
                    showLikes: false,
                    showAddModal: false,
                    showEditSetModal: false,
                    showProfileModal: false,
                    contextMenu: { show: false, x: 0, y: 0, target: null },
                    playingId: null,
                    loadingId: null,
                    hoverTrackId: null
                },

                // --- 2. DATA MODELS ---
                activeSet: null, 
                activeTrack: null, 
                
                // Data Arrays (Initialized empty to prevent "not defined" errors)
                sets: [],
                tracks: [],
                likedTracks: [],
                rescanCandidates: [],
                folders: [],
                
                queueStatus: { 
                    active: null, 
                    queue: [], 
                    history: [] 
                },
                
                dashboardStats: { 
                    total_sets: 0, 
                    total_tracks: 0, 
                    discovery_rate: 0,
                    top_artists: [],
                    recent_sets: [],
                    top_producers: [],
                    top_djs: []
                },

                // Inputs
                inputs: { url: '', metaArtist: '', metaName: '', metaEvent: '', metaTags: '', is_b2b: false, isLoadingMeta: false },
                editSetData: { id: null, name: '', artists: '', event: '', is_b2b: false, tags: '' },
                
                // Audio State
                audio: { paused: true, currentTime: 0, duration: 0, volume: 1, progressPercent: 0 },
                
                auth: { user: { name: 'User' }, dropdownOpen: false },
                toasts: [],
                youtubeFeed: [],

                // --- 3. INIT ---
                async init() {
                    console.log("Initializing Tracklistify...");
                    await this.fetchUser();
                    await this.fetchDashboard();
                    await this.fetchSets();
                    await this.fetchQueue();
                    await this.fetchLikes();
                    
                    // Poll Queue every 3 seconds
                    setInterval(() => this.fetchQueue(), 3000);
                },

                // --- 4. DATA FETCHING ---
                async fetchUser() {
                    try {
                        const res = await fetch('/api/auth/me');
                        if (res.ok) this.auth.user = await res.json();
                    } catch (e) { console.error("Auth check failed", e); }
                },

                async fetchDashboard() {
                    try {
                        const res = await fetch('/api/dashboard/stats');
                        if (res.ok) this.dashboardStats = await res.json();
                    } catch (e) { console.error("Dashboard load failed", e); }
                },

                async fetchSets() {
                    try {
                        const res = await fetch('/api/sets');
                        if (res.ok) this.sets = await res.json();
                    } catch (e) { console.error("Sets load failed", e); }
                },

                async loadSet(set) {
                    this.activeSet = set;
                    this.currentView = 'sets';
                    this.tracks = []; 
                    try {
                        const res = await fetch(`/api/sets/${set.id}/tracks`);
                        if (res.ok) this.tracks = await res.json();
                    } catch (e) { this.showToast('Error', 'Could not load tracks'); }
                },

                async fetchQueue() {
                    try {
                        const res = await fetch('/api/queue/status');
                        if (res.ok) this.queueStatus = await res.json();
                    } catch (e) { }
                },

                async fetchLikes() {
                    try {
                        const res = await fetch('/api/tracks/likes');
                        if (res.ok) this.likedTracks = await res.json();
                    } catch (e) { }
                },

                get filteredSets() {
                    if (this.search === '') return this.sets;
                    return this.sets.filter(s => s.name.toLowerCase().includes(this.search.toLowerCase()));
                },

                // --- 5. AUDIO LOGIC ---
                togglePlay(track) { 
                    const player = this.$refs.player;
                    if (!player) return;

                    // Same track clicked? Toggle pause/play
                    if (this.activeTrack && this.activeTrack.id === track.id) {
                        if (player.paused) player.play(); else player.pause();
                        return;
                    } 
                    
                    // New track clicked
                    this.activeTrack = track;
                    this.ui.playingId = track.id;
                    player.src = `/api/stream/${track.id}`; 
                    
                    // Wait for metadata to load before seeking
                    const onMeta = () => {
                        player.currentTime = track.start_time || 0;
                        player.play().catch(e => console.log("Auto-play prevented", e));
                    };
                    
                    player.addEventListener('loadedmetadata', onMeta, { once: true });
                    player.load();
                },

                togglePlayPauseGlobal() {
                    const player = this.$refs.player;
                    if (player.paused) player.play(); else player.pause();
                },

                updateProgress(e) {
                    this.audio.currentTime = e.target.currentTime;
                    this.audio.duration = e.target.duration || 0;
                    this.audio.progressPercent = this.audio.duration ? (this.audio.currentTime / this.audio.duration) * 100 : 0;
                },

                seek(e, track) {
                    if (this.activeTrack && this.activeTrack.id === track.id) {
                        this.seekGlobal(e);
                    } else {
                        this.togglePlay(track);
                    }
                },

                seekGlobal(e) {
                    const rect = e.currentTarget.getBoundingClientRect();
                    const pos = (e.clientX - rect.left) / rect.width;
                    const player = this.$refs.player;
                    if(player && player.duration) player.currentTime = pos * player.duration;
                },

                updateVolume(e) { this.$refs.player.volume = e.target.value; },
                onAudioEnded() { this.audio.paused = true; this.ui.playingId = null; },
                onAudioPaused() { this.audio.paused = true; },
                onAudioPlaying() { this.audio.paused = false; },
                onAudioError() { console.log('Audio Error - Check file path'); },

                // --- 6. UTILITIES ---
                
                queueProgressValue() {
                    return (this.queueStatus && this.queueStatus.active) ? this.queueStatus.active.progress : 0;
                },

                getPhaseLabel(phase) {
                    if (!phase) return 'Bereit';
                    const map = { downloading: 'Download', analyzing: 'Analyse', importing: 'Import', error: 'Fehler' };
                    return map[phase] || phase;
                },

                getPhaseColor(phase) { 
                    if(phase === 'error') return 'bg-red-500';
                    if(phase === 'done') return 'bg-green-500';
                    return 'bg-orange-500'; 
                },

                formatTime(s) { 
                    if(!s) return '00:00'; 
                    try {
                        return new Date(s * 1000).toISOString().substr(14, 5);
                    } catch(e) { return '00:00'; }
                },
                
                formatDate(d) { return d ? new Date(d).toLocaleDateString('de-DE') : ''; },
                formatConf(v) { return v ? Math.round(v * 100) + '%' : '-'; },
                getConfColor(v) { return v > 0.8 ? 'text-green-600' : 'text-orange-500'; },
                
                getSearchLink(t, s) { 
                    if (!t) return '#';
                    const q = encodeURIComponent(`${t.artist} ${t.title}`);
                    if (s === 'beatport') return `https://www.beatport.com/search?q=${q}`;
                    if (s === 'youtube') return `https://www.youtube.com/results?search_query=${q}`;
                    return '#';
                },

                isProducerFavorite(id) { return false; }, // Placeholder

                // --- 7. ACTIONS ---
                async fetchUrlMetadata(url) {
                    if(!url) return;
                    this.inputs.isLoadingMeta = true;
                    try {
                        const res = await fetch('/api/import/metadata', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({url})
                        });
                        if (res.ok) {
                            const data = await res.json();
                            this.inputs.metaName = data.title;
                            this.inputs.metaArtist = data.artist;
                            this.inputs.metaEvent = data.event;
                        }
                    } catch(e) { this.showToast('Error', 'Metadata fetch failed'); }
                    finally { this.inputs.isLoadingMeta = false; }
                },

                async addToQueue(type) {
                    const endpoint = type === 'url' ? '/api/import/url' : '/api/queue/add';
                    
                    // Specific payload for URL import
                    let body, headers;
                    if (type === 'url') {
                        body = JSON.stringify({
                            url: this.inputs.url,
                            artist: this.inputs.metaArtist,
                            title: this.inputs.metaName,
                            is_b2b: this.inputs.is_b2b
                        });
                        headers = {'Content-Type': 'application/json'};
                    } else {
                        // File upload (Mock implementation or Form Data needed here)
                        // For now assuming URL flow is primary
                        return; 
                    }

                    try {
                        const res = await fetch(endpoint, { method: 'POST', headers, body });
                        if(res.ok) {
                            this.showToast('Erfolg', 'Import gestartet');
                            this.ui.showAddModal = false;
                            this.fetchQueue(); 
                            this.inputs.url = ''; 
                        } else {
                            this.showToast('Fehler', 'Konnte Job nicht starten');
                        }
                    } catch(e) { this.showToast('Error', 'Import failed'); }
                },

                openEditSetModal() { 
                    if (this.activeSet) {
                        this.editSetData = { ...this.activeSet }; 
                        this.ui.showEditSetModal = true; 
                    }
                },
                
                async saveSetMetadata() {
                    try {
                        const res = await fetch(`/api/sets/${this.editSetData.id}/metadata`, {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify(this.editSetData)
                        });
                        if(res.ok) {
                            this.showToast('Gespeichert', 'Metadaten aktualisiert');
                            this.ui.showEditSetModal = false;
                            this.fetchSets();
                            // Update active view
                            this.activeSet = { ...this.activeSet, ...this.editSetData };
                        }
                    } catch(e) { this.showToast('Error', 'Speichern fehlgeschlagen'); }
                },

                async deleteSetContext() {
                    const set = this.ui.contextMenu.target;
                    if(!confirm(`Set "${set.name}" wirklich löschen?`)) return;
                    try {
                        await fetch(`/api/sets/${set.id}`, { method: 'DELETE' });
                        this.showToast('Gelöscht', 'Set entfernt');
                        this.fetchSets();
                        if(this.activeSet && this.activeSet.id === set.id) this.showDashboard();
                    } catch(e) { this.showToast('Error', 'Löschen fehlgeschlagen'); }
                },
                
                async toggleLike(track) {
                    if(!track) return;
                    // Optimistic update
                    track.liked = !track.liked; 
                    try {
                        await fetch(`/api/tracks/${track.id}/like`, { 
                            method: 'POST', 
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({liked: track.liked})
                        });
                        this.fetchLikes(); 
                    } catch(e) { track.liked = !track.liked; }
                },

                async togglePurchase(track) {
                    if(!track) return;
                    track.purchased = !track.purchased;
                    await fetch(`/api/tracks/${track.id}/purchase`, { 
                        method: 'POST', 
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({purchased: track.purchased})
                    });
                },

                async stopQueue() {
                    await fetch('/api/queue/stop', { method: 'POST' });
                    this.showToast('Stop', 'Queue angehalten');
                    this.fetchQueue();
                },

                showToast(title, subtitle) {
                    const id = Date.now();
                    this.toasts.push({id, title, subtitle});
                    setTimeout(() => { this.toasts = this.toasts.filter(t => t.id !== id); }, 3000);
                },

                // Placeholders
                toggleProducerFavorite(item) {},
                rescanSetContext() {},
                renameSetContext() {},
                
                logout() { window.location.href = '/logout'; }
            }))
        })
    </script>
</head>
<body class="h-full flex flex-col" x-data="tracklistify()">

    <div class="app-shell">
        
        <aside class="swiss-sidebar">
             {% include 'components/sidebar_sets.html' %}
        </aside>

        <section class="main-content">
            
            {% include 'components/header.html' %}

            <div class="view-container">
                
                <div x-show="currentView === 'dashboard'" class="h-full">
                    {% include 'components/dashboard.html' %}
                </div>

                <div x-show="currentView === 'sets'" x-cloak class="h-full">
                    {% include 'components/main_view.html' %}
                </div>

                <div x-show="currentView === 'queue'" x-cloak class="h-full">
                    {% include 'components/queue_view.html' %}
                </div>

                <div x-show="currentView === 'rescan'" x-cloak class="h-full">
                    {% include 'components/rescan_view.html' %}
                </div>

            </div>
        </section>

        {% include 'components/sidebar_likes.html' %}

    </div>

    {% include 'components/footer_player.html' %}

    {% include 'components/modals.html' %}

    <div class="toast-stack">
        <template x-for="toast in toasts" :key="toast.id">
            <div class="toast">
                <div class="title" x-text="toast.title"></div>
                <div class="subtitle" x-text="toast.subtitle"></div>
            </div>
        </template>
    </div>

</body>
</html>